#include "pch.h"

#include <iostream>
#include <fstream>
#include <string>
#include <stdint.h>
#include <set>
#include <iomanip>
#include <mutex>
#include <vector>
#include <unordered_set>
#include <windows.h>
#include <thread>
#include <cstdarg>
#include <filesystem>

namespace fs = std::filesystem;
static char* exe_base = nullptr;

static std::ofstream g_LogFile;
static std::mutex g_LogMutex;

struct RdbTypeInfo {
	std::string name;
	std::string extension;
};

RdbTypeInfo GetRdbTypeInfo(unsigned int typeId) {
    switch (typeId) {
        // common files
    case 0xAFBEC60C:
        return {
          "TexContext", ".g1t"
        };
    case 0xAD57EBBA:
        return {
          "StreamingTexContext", ".g1t"
        };
    case 0x563BDEF1:
        return {
          "ModelData", ".g1m"
        };
    case 0x786DCD84:
        return {
          "G1NFile", ".g1n"
        };
    case 0x17614AF5:
        return {
          "G1MXFile", ".g1mx"
        };
    case 0x6FA91671:
        return {
          "G1AFile", ".g1a"
        };
    case 0x7BCD279F:
        return {
          "G1SFile", ".g1s"
        };
    case 0x79C724C2:
        return {
          "G1PFile", ".g1p"
        };
    case 0x54738C76:
        return {
          "G1COFile", ".g1co"
        };
    case 0xA8D88566:
        return {
          "G1COXFile", ".g1cox"
        };
    case 0x7461C7CA:
        return {
          "G1HFile", ".g1h"
        };
    case 0xDB0AE0AA:
        return {
          "G1IIFile", ".gii"
        };
    case 0xB097D41F:
        return {
          "EffectData", ".g1e"
        };
    case 0x4D0102AC:
        return {
          "EffectMeshData", ".g1em"
        };
    case 0x1A6300FD:
        return {
          "EffectShapeMeshData", ".g1es"
        };
    case 0x2BCC0C02:
        return {
          "FRAnimationData", ".g1frani"
        };
    case 0x32AC9403:
        return {
          "FPoseData", ".g1fpose"
        };

        // system db
    case 0x20A6A0BB:
        return {
          "ObjectDatabaseFile", ".kidsobjdb"
        };
    case 0xBF6B52C7:
        return {
          "NameDatabaseFile", ".name"
        };
    case 0x1FDCAA40:
        return {
          "TaskGraphFile", ".kidstask"
        };
    case 0xB1630F51:
        return {
          "RenderGraphFile", ".kidsrender"
        };
    case 0xBE144B78:
        return {
          "KTIDFile", ".ktid"
        };
    case 0x8E39AA37:
        return {
          "KTIDFileBinary", ".ktid"
        };
    case 0xB0A14534:
        return {
          "GlobalConfiguration", ".sgcbin"
        };
    case 0x8D735C52:
        return {
          "OBOROStaticResourceBinaryFile", ".oboro"
        };

        // bindings and tables
    case 0x1AB40AE8:
        return {
          "OIDBindTableBinaryFile", ".oid"
        };
    case 0xDBCB74A9:
        return {
          "OIDFile", ".oid"
        };
    case 0xE6A3C3BB:
        return {
          "OIDBindTableBinaryFileEx", ".oidex"
        };
    case 0x9CB3A4B6:
        return {
          "OIDExFile", ".oidex"
        };
    case 0x753AA042:
        return {
          "OIDSQTBindTableBinaryFile", ".oidsq"
        };
    case 0xB340861A:
        return {
          "MaterialGroupBindTableBinaryFile", ".mtl"
        };
    case 0x56EFE45C:
        return {
          "PartsModelGroupBindTableBinaryFile", ".grp"
        };
    case 0xBBF9B49D:
        return {
          "GroupFile", ".grp"
        };
    case 0x27BC54B7:
        return {
          "RigBinFile", ".rigbin"
        };

        // scripts and collisions
    case 0x5599AA51:
        return {
          "KSCLFile", ".kscl"
        };
    case 0x4F16D0EF:
        return {
          "KTSFile", ".kts"
        };
    case 0xED410290:
        return {
          "TexStageTableBinaryFile", ".kts"
        };

        // ui and text
    case 0xA1BDB205:
        return {
          "G2NFile", ".g2n"
        };
    case 0x96C74B4F:
        return {
          "G2NGlyphSetFile", ".g2n"
        };
    case 0xC9D883C2:
        return {
          "ScreenLayoutColorTableBinaryFile", ".colortable"
        };
    case 0xF13845EF:
        return {
          "ScreenLayoutShapeInfoFile", ".sclshape"
        };
    case 0xF20DE437:
        return {
          "StaticScreenLayoutTexInfoFile", ".texinfo"
        };

        // audio and video
    case 0xBBD39F2D:
        return {
          "AssetData", ".srsa"
        };
    case 0x0D34474D:
        return {
          "StreamAssetDataFile", ".srst"
        };
    case 0x133D2C3B:
        return {
          "ShaderBindTableBinaryFile", ".sid"
        };
    case 0xA027E46B:
        return {
          "VideoStreamset", ".mov"
        };
    case 0xBEF563DD:
        return {
          "StreamingMeshletModelData", ".g1m"
        };

    case 0x5B2970FC:
        return {
          "KTF2File", ".ktf2"
        };
    case 0xD7F47FB1:
        return {
          "BinaryFile", ".efpl"
        };
    case 0x193D2E44:
        return {
          "RBFData", ".grbf"
        };
    case 0x4638B72D:
        return {
          "River2BakedGeometry", ".rbg"
        };
    case 0x5C3E543C:
        return {
          "SwingData", ".swg"
        };
    case 0x82945A44:
        return {
          "LandscapeQuadtree", ".lsqtree"
        };
    case 0xCBFD49B2:
        return {
          "MotionMatchingDatabase", ".mmdb"
        };
    case 0x0BD05B27:
        return {
          "MITFile", ".mit"
        };
    case 0x6DBD6EA6:
        return {
          "CSVFile", ".mit"
        };
    case 0xF02F31AB:
        return {
          "OIDBindTable", ""
        };

    default: {
        char buffer[32];
        sprintf_s(buffer, "Unknown_0x%08X", typeId);
        return {
          buffer,
          ""
        };
    }
    }
}

void ModLog(const char* format, ...) {
	std::lock_guard<std::mutex> lock(g_LogMutex);

	if (!g_LogFile.is_open())
		return;

	char buffer[1024];
	va_list args;
	va_start(args, format);
	vsnprintf(buffer, sizeof(buffer), format, args);
	va_end(args);

	g_LogFile << buffer << std::endl;
	g_LogFile.flush();
}

std::uint8_t* PatternScan(void* module, const char* signature)
{
	static auto pattern_to_byte = [](const char* pattern) {
		auto bytes = std::vector<int>{};
		auto start = const_cast<char*>(pattern);
		auto end = const_cast<char*>(pattern) + strlen(pattern);

		for (auto current = start; current < end; ++current) {
			if (*current == '?') {
				++current;
				if (*current == '?')
					++current;
				bytes.push_back(-1);
			}
			else {
				bytes.push_back(strtoul(current, &current, 16));
			}
		}
		return bytes;
		};

	auto dosHeader = (PIMAGE_DOS_HEADER)module;
	auto ntHeaders = (PIMAGE_NT_HEADERS)((std::uint8_t*)module + dosHeader->e_lfanew);

	auto sizeOfImage = ntHeaders->OptionalHeader.SizeOfImage;
	auto patternBytes = pattern_to_byte(signature);
	auto scanBytes = reinterpret_cast<std::uint8_t*>(module);

	auto s = patternBytes.size();
	auto d = patternBytes.data();

	for (auto i = 0ul; i < sizeOfImage - s; ++i) {
		bool found = true;
		for (auto j = 0ul; j < s; ++j) {
			if (scanBytes[i + j] != d[j] && d[j] != -1) {
				found = false;
				break;
			}
		}
		if (found) {
			return &scanBytes[i];
		}
	}
	return nullptr;
}

typedef unsigned int(__fastcall* Rdb_FindIndexByKtid_t)(__int64 archive_manager, uintptr_t entry_ptr);
Rdb_FindIndexByKtid_t Rdb_FindIndexByKtid = nullptr;

typedef __int64(__fastcall* VFS_MountResource_t)(
	uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4,
	uintptr_t a5, uintptr_t a6, uintptr_t a7, uintptr_t a8,
	uintptr_t a9, uintptr_t a10, uintptr_t a11, uintptr_t a12,
	uintptr_t a13, uintptr_t a14
	);

VFS_MountResource_t oVFS_MountResource = nullptr;

__int64 __fastcall hVFS_MountResource(
	uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4,
	uintptr_t a5, uintptr_t a6, uintptr_t a7, uintptr_t a8,
	uintptr_t a9, uintptr_t a10, uintptr_t a11, uintptr_t a12,
	uintptr_t a13, uintptr_t a14)
{
	if (Rdb_FindIndexByKtid != nullptr && a3 != 0 && a7 > 0)
	{
		unsigned int realHash = (unsigned int)Rdb_FindIndexByKtid(a3 + 536, a7);
		unsigned int resType = *(unsigned int*)(a7 + 8);

		if (realHash != 0xFFFFFFFF) {
			RdbTypeInfo info = GetRdbTypeInfo(resType);

			printf("[VFS] Hash: 0x%08X | Type: %s (%s)\n",
				realHash, info.name.c_str(), info.extension.c_str());

			ModLog("[VFS] Hash: 0x%08X | Type: %s (%s)",
				realHash, info.name.c_str(), info.extension.c_str());
		}
	}

	return oVFS_MountResource(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
}

void SetupConsole() {
	AllocConsole();
	FILE* fDummy;
	freopen_s(&fDummy, "CONOUT$", "w", stdout);
	freopen_s(&fDummy, "CONOUT$", "w", stderr);

	std::cout << "Console Initialized. Waiting for VFS events..." << std::endl;
}

void InitializeHooks()
{
	g_LogFile.open("mod_vfs_log.txt", std::ios::out);
	ModLog("--- Loader Logger Started ---");
	if (MH_Initialize() != MH_OK)
		return;

	const char* vfs_mount_pattern = "40 55 56 57 41 54 41 55 41 56 41 57 48 81 EC ? ? ? ? 48 8D 6C 24 ? 48 89 9D ? ? ? ? 48 8B 05 ? ? ? ? 48 33 C5 48 89 85 ? ? ? ? 48 8B 85 ? ? ? ? 4D 8B F0";
	const char* rdb_find_index_by_ktid_pattern = "40 53 48 83 EC ? 48 8B D9 E8 ? ? ? ? 44 8B D0";

	void* mountResourceAddr = (void*)PatternScan(GetModuleHandleA(NULL), vfs_mount_pattern);
	void* getRddbEntryIdAddr = (void*)PatternScan(GetModuleHandleA(NULL), rdb_find_index_by_ktid_pattern);

	if (getRddbEntryIdAddr && mountResourceAddr)
	{
		Rdb_FindIndexByKtid = (Rdb_FindIndexByKtid_t)(getRddbEntryIdAddr);
		if (MH_CreateHook(mountResourceAddr, (LPVOID)hVFS_MountResource, (LPVOID*)&oVFS_MountResource) == MH_OK)
		{
			MH_EnableHook(mountResourceAddr);
		}
	}
	else
	{
		MessageBoxA(0, "Pattern not found! Check game version.", "Error", MB_ICONERROR);
	}
}

void MainThread()
{
	Sleep(2000);
	SetupConsole();
	InitializeHooks();
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)MainThread, NULL, 0, NULL);
		break;
	case DLL_PROCESS_DETACH:
		MH_Uninitialize();
		break;
	}
	return TRUE;
}